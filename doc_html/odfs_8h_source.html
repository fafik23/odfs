<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>odfs: odfs.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>odfs.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ODFS</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ODFS</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#include &lt;fuse.h&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;liblmdb/lmdb.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;fifo.h&quot;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#define ODFS_DATA_BLOCK_SIZE 4080</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define ODFS_DISPLAYNAME_SIZE 128</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define MAX_ID 40</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="comment">/*</span>
<a name="l00013"></a>00013 <span class="comment">typedef struct odfs_id_list {</span>
<a name="l00014"></a>00014 <span class="comment">    unsigned int number_of_ids; // 0 means empty list</span>
<a name="l00015"></a>00015 <span class="comment">    unsigned int id_list[MAX_ID];</span>
<a name="l00016"></a>00016 <span class="comment">} odfs_id_list;</span>
<a name="l00017"></a>00017 <span class="comment">*/</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> <a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a>;
<a name="l00021"></a>00021 
<a name="l00026"></a><a class="code" href="structodfs__id__list__node.html">00026</a> <span class="keyword">struct </span><a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a>
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> odfs_id;
<a name="l00029"></a>00029         <a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> *next;
<a name="l00030"></a>00030 };
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="structodfs__id__list__head.html">00033</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_ids; <span class="comment">// 0 means empty list</span>
<a name="l00036"></a>00036         <a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> *next;
<a name="l00037"></a>00037 } <a class="code" href="structodfs__id__list__head.html">odfs_id_list_head</a>;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00040"></a>00040     CTX_PLUGIN_INIT = 0, 
<a name="l00041"></a>00041     CTX_PLUGIN_GET, 
<a name="l00042"></a>00042     CTX_PLUGIN_ADD, 
<a name="l00043"></a>00043     CTX_PLUGIN_DEL,
<a name="l00044"></a>00044     CTX_PLUGIN_FINI,
<a name="l00045"></a>00045     CTX_PLUGIN_RETAG,
<a name="l00046"></a>00046     CTX_PLUGIN_PP,
<a name="l00047"></a>00047 } odfs_tag_plugin_context;
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="structodfs__key.html">00049</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__key.html">odfs_key</a> {
<a name="l00050"></a>00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> odfs_file_id;
<a name="l00051"></a>00051     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> odfs_file_part;
<a name="l00052"></a>00052 } <a class="code" href="structodfs__key.html">odfs_key</a>;
<a name="l00053"></a>00053 <span class="comment">//typedef unsigned int odfs_file_id;</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="structodfs__posix__data.html">00055</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__posix__data.html">odfs_posix_data</a>{
<a name="l00056"></a>00056     <span class="keyword">struct </span>stat odfs_posix_stat ;
<a name="l00057"></a>00057     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> odfs_file_id;
<a name="l00058"></a>00058     <span class="keywordtype">char</span> display_name[ODFS_DISPLAYNAME_SIZE];
<a name="l00059"></a>00059 } <a class="code" href="structodfs__posix__data.html">odfs_posix_data</a>;
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="structodfs__file.html">00061</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__file.html">odfs_file</a> {
<a name="l00062"></a>00062     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id;
<a name="l00063"></a>00063     <span class="keyword">struct </span><a class="code" href="structodfs__posix__data.html">odfs_posix_data</a> opd_cache;
<a name="l00064"></a>00064     MDB_txn *write_txn;
<a name="l00065"></a>00065     MDB_dbi write_dbi;
<a name="l00066"></a>00066     MDB_dbi read_dbi;
<a name="l00067"></a>00067     MDB_txn *read_txn;
<a name="l00068"></a>00068     pthread_mutex_t read_lock;
<a name="l00069"></a>00069     <a class="code" href="structfifo__t.html">fifo_t</a> write_fifo;
<a name="l00070"></a>00070     off_t offset;
<a name="l00071"></a>00071 } <a class="code" href="structodfs__file.html">odfs_file</a>;
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="structodfs__wrequest.html">00073</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__wrequest.html">odfs_wrequest</a> {
<a name="l00074"></a>00074     MDB_val key;
<a name="l00075"></a>00075     MDB_val data;
<a name="l00076"></a>00076     <span class="keywordtype">int</span> data_free_flag;
<a name="l00077"></a>00077     <span class="comment">//pthread_cond_t flag;</span>
<a name="l00078"></a>00078     <span class="keyword">volatile</span> <span class="keywordtype">int</span> flag;
<a name="l00079"></a>00079 } <a class="code" href="structodfs__wrequest.html">odfs_wrequest</a>;
<a name="l00080"></a>00080 
<a name="l00081"></a><a class="code" href="structodfs__tag__plugin.html">00081</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__tag__plugin.html">odfs_tag_plugin</a> {
<a name="l00082"></a>00082     <span class="keywordtype">char</span> name[100];
<a name="l00083"></a>00083     int (*<span class="keyword">get</span>)(<span class="keywordtype">char</span> *,<span class="keyword">struct </span><a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> *) ;
<a name="l00084"></a>00084     int (*<a class="code" href="odfs__name_8c.html#a4c053377c30ae538162c70c8963b5e0a">add</a>)(<span class="keywordtype">char</span> *,<span class="keyword">struct </span><a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> *) ;
<a name="l00085"></a>00085     <span class="comment">//int (*add)(unsigned int,char *) ;</span>
<a name="l00086"></a>00086     int (*<a class="code" href="odfs__name_8c.html#abcd12978588444af4f02f2cd2955936f">del</a>)(<span class="keywordtype">unsigned</span> int,<span class="keywordtype">char</span> *) ;
<a name="l00087"></a>00087     int (*list_tag)(<span class="keywordtype">char</span> **) ;
<a name="l00088"></a>00088     int (*run)(<a class="code" href="structodfs__file.html">odfs_file</a> * file,odfs_tag_plugin_context) ;
<a name="l00089"></a>00089     int (*<a class="code" href="odfs__name_8c.html#a05848de25ac2dbec233935058a1d24b4">init</a>)() ;
<a name="l00090"></a>00090     int (*<a class="code" href="odfs__name_8c.html#a04f3cf75fa304ce42b05a4dd75ec5786">fini</a>)() ;
<a name="l00091"></a>00091 } <a class="code" href="structodfs__tag__plugin.html">odfs_tag_plugin</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="structodfs__tag__stack.html">00093</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a> {
<a name="l00094"></a>00094     <span class="keyword">struct  </span><a class="code" href="structodfs__tag__plugin.html">odfs_tag_plugin</a> * plugin;
<a name="l00095"></a>00095     <span class="keyword">struct </span><a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a> * next;
<a name="l00096"></a>00096 } <a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a>;
<a name="l00097"></a>00097 
<a name="l00103"></a><a class="code" href="structodfs__tag__query.html">00103</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structodfs__tag__query.html" title="...">odfs_tag_query</a> {
<a name="l00104"></a>00104     <span class="keywordtype">char</span> * plugin_name;
<a name="l00105"></a>00105     <span class="keywordtype">char</span> * tag_string;
<a name="l00106"></a>00106     <a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> * list;
<a name="l00107"></a>00107     <a class="code" href="structodfs__id__list__node.html" title="nod listy przechowujacej id plikow">odfs_id_list_node</a> *plugin_return_list; <span class="comment">//konflikt w strukturze i process path</span>
<a name="l00108"></a>00108     odfs_tag_plugin_context context;
<a name="l00109"></a>00109 } <a class="code" href="structodfs__tag__query.html" title="...">odfs_tag_query</a>;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keywordtype">int</span> odfs_run_plugin(<span class="keyword">struct</span> <a class="code" href="structodfs__tag__plugin.html">odfs_tag_plugin</a> * plugin, <span class="keyword">struct</span> <a class="code" href="structodfs__tag__query.html" title="...">odfs_tag_query</a> * query);
<a name="l00113"></a>00113 <span class="keywordtype">int</span> odfs_run_plugin_stack(<span class="keyword">struct</span> <a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a> * stack, <span class="keyword">struct</span> <a class="code" href="structodfs__tag__query.html" title="...">odfs_tag_query</a> * query);
<a name="l00114"></a>00114 <span class="keywordtype">int</span> odfs_init_plugin_stack(<span class="keyword">struct</span> <a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a> ** stack);
<a name="l00115"></a>00115 <span class="keywordtype">int</span> odfs_add_to_plugin_stack(<span class="keyword">struct</span> <a class="code" href="structodfs__tag__stack.html">odfs_tag_stack</a> ** stack, <span class="keyword">struct</span> <a class="code" href="structodfs__tag__plugin.html">odfs_tag_plugin</a> * plugin);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structodfs__file.html">odfs_file</a> *get_odfs_file(<span class="keyword">struct</span> fuse_file_info *fi)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structodfs__file.html">odfs_file</a> *) (uintptr_t) fi-&gt;fh;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">//    Initialize the filesystem. This function can often be left unimplemented, but it can be a handy way to perform one-time setup such as allocating variable-sized data structures or initializing a new filesystem. The fuse_conn_info structure gives information about what features are supported by FUSE, and can be used to request certain capabilities (see below for more information). The return value of this function is available to all file operations in the private_data field of fuse_context. It is also passed as a parameter to the destroy() method. (Note: see the warning under Other Options below, regarding relative pathnames.) </span>
<a name="l00123"></a>00123 <span class="keywordtype">void</span>* odfs_init(<span class="keyword">struct</span> fuse_conn_info *conn);
<a name="l00124"></a>00124 <span class="comment">//    Called when the filesystem exits. The private_data comes from the return value of init. </span>
<a name="l00125"></a>00125 <span class="keywordtype">void</span> odfs_destroy(<span class="keywordtype">void</span>* private_data);
<a name="l00126"></a>00126  <span class="comment">//   Return file attributes. The &quot;stat&quot; structure is described in detail in the stat(2) manual page. For the given pathname, this should fill in the elements of the &quot;stat&quot; structure. If a field is meaningless or semi-meaningless (e.g., st_ino) then it should be set to 0 or given a &quot;reasonable&quot; value. This call is pretty much required for a usable filesystem. </span>
<a name="l00127"></a>00127 <span class="keywordtype">int</span> odfs_getattr(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> stat* stbuf);
<a name="l00128"></a>00128   <span class="comment">//  As getattr, but called when fgetattr(2) is invoked by the user program. </span>
<a name="l00129"></a>00129 <span class="keywordtype">int</span> odfs_fgetattr(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> stat* stbuf);
<a name="l00130"></a>00130    <span class="comment">// This is the same as the access(2) system call. It returns -ENOENT if the path doesn&apos;t exist, -EACCESS if the requested permission isn&apos;t available, or 0 for success. Note that it can be called on files, directories, or any other object that appears in the filesystem. This call is not required but is highly recommended. </span>
<a name="l00131"></a>00131 <span class="keywordtype">int</span> odfs_access(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">int</span> mask);
<a name="l00132"></a>00132     <span class="comment">//If path is a symbolic link, fill buf with its target, up to size. See readlink(2) for how to handle a too-small buffer and for error codes. Not required if you don&apos;t support symbolic links. NOTE: Symbolic-link support requires only readlink and symlink. FUSE itself will take care of tracking symbolic links in paths, so your path-evaluation code doesn&apos;t need to worry about it. </span>
<a name="l00133"></a>00133 <span class="keywordtype">int</span> odfs_readlink(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span> size);
<a name="l00134"></a>00134     <span class="comment">//Open a directory for reading. </span>
<a name="l00135"></a>00135 <span class="keywordtype">int</span> odfs_opendir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00136"></a>00136     <span class="comment">//Return one or more directory entries (struct dirent) to the caller. This is one of the most complex FUSE functions. It is related to, but not identical to, the readdir(2) and getdents(2) system calls, and the readdir(3) library function. Because of its complexity, it is described separately below. Required for essentially any filesystem, since it&apos;s what makes ls and a whole bunch of other things work. </span>
<a name="l00137"></a>00137 <span class="keywordtype">int</span> odfs_readdir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">void</span>* buf, fuse_fill_dir_t filler, off_t offset, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00138"></a>00138     <span class="comment">//Make a special (device) file, FIFO, or socket. See mknod(2) for details. This function is rarely needed, since it&apos;s uncommon to make these objects inside special-purpose filesystems. </span>
<a name="l00139"></a>00139 <span class="keywordtype">int</span> odfs_mknod(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, mode_t mode, dev_t rdev);
<a name="l00140"></a>00140     <span class="comment">//Create a directory with the given name. The directory permissions are encoded in mode. See mkdir(2) for details. This function is needed for any reasonable read/write filesystem. </span>
<a name="l00141"></a>00141 <span class="keywordtype">int</span> odfs_mkdir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, mode_t mode);
<a name="l00142"></a>00142     <span class="comment">//Remove (delete) the given file, symbolic link, hard link, or special node. Note that if you support hard links, unlink only deletes the data when the last hard link is removed. See unlink(2) for details. </span>
<a name="l00143"></a>00143 <span class="keywordtype">int</span> odfs_unlink(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);
<a name="l00144"></a>00144     <span class="comment">//Remove the given directory. This should succeed only if the directory is empty (except for &quot;.&quot; and &quot;..&quot;). See rmdir(2) for details. </span>
<a name="l00145"></a>00145 <span class="keywordtype">int</span> odfs_rmdir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);
<a name="l00146"></a>00146     <span class="comment">//Create a symbolic link named &quot;from&quot; which, when evaluated, will lead to &quot;to&quot;. Not required if you don&apos;t support symbolic links. NOTE: Symbolic-link support requires only readlink and symlink. FUSE itself will take care of tracking symbolic links in paths, so your path-evaluation code doesn&apos;t need to worry about it. </span>
<a name="l00147"></a>00147 <span class="keywordtype">int</span> odfs_symlink(<span class="keyword">const</span> <span class="keywordtype">char</span>* to, <span class="keyword">const</span> <span class="keywordtype">char</span>* from);
<a name="l00148"></a>00148     <span class="comment">//Rename the file, directory, or other object &quot;from&quot; to the target &quot;to&quot;. Note that the source and target don&apos;t have to be in the same directory, so it may be necessary to move the source to an entirely new directory. See rename(2) for full details. </span>
<a name="l00149"></a>00149 <span class="keywordtype">int</span> odfs_rename(<span class="keyword">const</span> <span class="keywordtype">char</span>* from, <span class="keyword">const</span> <span class="keywordtype">char</span>* to);
<a name="l00150"></a>00150     <span class="comment">//Create a hard link between &quot;from&quot; and &quot;to&quot;. Hard links aren&apos;t required for a working filesystem, and many successful filesystems don&apos;t support them. If you do implement hard links, be aware that they have an effect on how unlink works. See link(2) for details. </span>
<a name="l00151"></a>00151 <span class="keywordtype">int</span> odfs_link(<span class="keyword">const</span> <span class="keywordtype">char</span>* from, <span class="keyword">const</span> <span class="keywordtype">char</span>* to);
<a name="l00152"></a>00152     <span class="comment">//Change the mode (permissions) of the given object to the given new permissions. Only the permissions bits of mode should be examined. See chmod(2) for details. </span>
<a name="l00153"></a>00153 <span class="keywordtype">int</span> odfs_chmod(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, mode_t mode);
<a name="l00154"></a>00154     <span class="comment">//Change the given object&apos;s owner and group to the provided values. See chown(2) for details. NOTE: FUSE doesn&apos;t deal particularly well with file ownership, since it usually runs as an unprivileged user and this call is restricted to the superuser. It&apos;s often easier to pretend that all files are owned by the user who mounted the filesystem, and to skip implementing this function. </span>
<a name="l00155"></a>00155 <span class="keywordtype">int</span> odfs_chown(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, uid_t uid, gid_t gid);
<a name="l00156"></a>00156     <span class="comment">//Truncate or extend the given file so that it is precisely size bytes long. See truncate(2) for details. This call is required for read/write filesystems, because recreating a file will first truncate it. </span>
<a name="l00157"></a>00157 <span class="keywordtype">int</span> odfs_truncate(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, off_t size);
<a name="l00158"></a>00158     <span class="comment">//As truncate, but called when ftruncate(2) is called by the user program. </span>
<a name="l00159"></a>00159 <span class="keywordtype">int</span> odfs_ftruncate(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, off_t size);
<a name="l00160"></a>00160     <span class="comment">//Update the last access time of the given object from ts[0] and the last modification time from ts[1]. Both time specifications are given to nanosecond resolution, but your filesystem doesn&apos;t have to be that precise; see utimensat(2) for full details. Note that the time specifications are allowed to have certain special values; however, I don&apos;t know if FUSE functions have to support them. This function isn&apos;t necessary but is nice to have in a fully functional filesystem. </span>
<a name="l00161"></a>00161 <span class="keywordtype">int</span> odfs_utimens(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec ts[2] );
<a name="l00162"></a>00162     <span class="comment">//Open a file. If you aren&apos;t using file handles, this function should just check for existence and permissions and return either success or an error code. If you use file handles, you should also allocate any necessary structures and set fi-&gt;fh. In addition, fi has some other fields that an advanced filesystem might find useful; see the structure definition in fuse_common.h for very brief commentary. </span>
<a name="l00163"></a>00163 <span class="keywordtype">int</span> odfs_open(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info* fi) ;
<a name="l00164"></a>00164     <span class="comment">//Read size bytes from the given file into the buffer buf, beginning offset bytes into the file. See read(2) for full details. Returns the number of bytes transferred, or 0 if offset was at or beyond the end of the file. Required for any sensible filesystem. </span>
<a name="l00165"></a>00165 <span class="keywordtype">int</span> odfs_read(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> size, off_t offset, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00166"></a>00166     <span class="comment">//As for read above, except that it can&apos;t return 0. </span>
<a name="l00167"></a>00167 <span class="keywordtype">int</span> odfs_write(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> size, off_t offset, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00168"></a>00168     <span class="comment">//Return statistics about the filesystem. See statvfs(2) for a description of the structure contents. Usually, you can ignore the path. Not required, but handy for read/write filesystems since this is how programs like df determine the free space. </span>
<a name="l00169"></a>00169 <span class="keywordtype">int</span> odfs_statfs(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> statvfs* stbuf );
<a name="l00170"></a>00170     <span class="comment">//This is the only FUSE function that doesn&apos;t have a directly corresponding system call, although close(2) is related. Release is called when FUSE is completely done with a file; at that point, you can free up any temporarily allocated data structures. The IBM document claims that there is exactly one release per open, but I don&apos;t know if that is true. </span>
<a name="l00171"></a>00171 <span class="keywordtype">int</span> odfs_release(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info *fi);
<a name="l00172"></a>00172     <span class="comment">//This is like release, except for directories. </span>
<a name="l00173"></a>00173 <span class="keywordtype">int</span> odfs_releasedir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info *fi);
<a name="l00174"></a>00174     <span class="comment">//Flush any dirty information about the file to disk. If isdatasync is nonzero, only data, not metadata, needs to be flushed. When this call returns, all file data should be on stable storage. Many filesystems leave this call unimplemented, although technically that&apos;s a Bad Thing since it risks losing data. If you store your filesystem inside a plain file on another filesystem, you can implement this by calling fsync(2) on that file, which will flush too much data (slowing performance) but achieve the desired guarantee. </span>
<a name="l00175"></a>00175 <span class="keywordtype">int</span> odfs_fsync(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">int</span> isdatasync, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00176"></a>00176     <span class="comment">//Like fsync, but for directories. </span>
<a name="l00177"></a>00177 <span class="keywordtype">int</span> odfs_fsyncdir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">int</span> isdatasync, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00178"></a>00178     <span class="comment">//Called on each close so that the filesystem has a chance to report delayed errors. Important: there may be more than one flush call for each open. Note: There is no guarantee that flush will ever be called at all! </span>
<a name="l00179"></a>00179 <span class="keywordtype">int</span> odfs_flush(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info* fi);
<a name="l00180"></a>00180     <span class="comment">//Perform a POSIX file-locking operation. See details below. </span>
<a name="l00181"></a>00181 <span class="keywordtype">int</span> odfs_lock(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info* fi, <span class="keywordtype">int</span> cmd, <span class="keyword">struct</span> flock* locks);
<a name="l00182"></a>00182     <span class="comment">//Support the ioctl(2) system call. As such, almost everything is up to the filesystem. On a 64-bit machine, FUSE_IOCTL_COMPAT will be set for 32-bit ioctls. The size and direction of data is determined by _IOC_*() decoding of cmd. For _IOC_NONE, data will be NULL; for _IOC_WRITE data is being written by the user; for _IOC_READ it is being read, and if both are set the data is bidirectional. In all non-NULL cases, the area is _IOC_SIZE(cmd) bytes in size. </span>
<a name="l00183"></a>00183 <span class="keywordtype">int</span> odfs_ioctl(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">int</span> cmd, <span class="keywordtype">void</span>* arg, <span class="keyword">struct</span> fuse_file_info* fi, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <span class="keywordtype">void</span>* data);
<a name="l00184"></a>00184     <span class="comment">//Poll for I/O readiness. If ph is non-NULL, when the filesystem is ready for I/O it should call fuse_notify_poll (possibly asynchronously) with the specified ph; this will clear all pending polls. The callee is responsible for destroying ph with fuse_pollhandle_destroy() when ph is no longer needed. </span>
<a name="l00185"></a>00185 <span class="keywordtype">int</span> odfs_poll(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">struct</span> fuse_file_info* fi, <span class="keyword">struct</span> fuse_pollhandle* ph, <span class="keywordtype">unsigned</span>* reventsp);
<a name="l00186"></a>00186 <span class="comment">/*    //This function is similar to bmap(9). If the filesystem is backed by a block device, it converts blockno from a file-relative block number to a device-relative block. It isn&apos;t entirely clear how the blocksize parameter is intended to be used. </span>
<a name="l00187"></a>00187 <span class="comment">int setxattr(const char* path, const char* name, const char* value, size_t size, int flags)</span>
<a name="l00188"></a>00188 <span class="comment">    //Set an extended attribute. See setxattr(2). This should be implemented only if HAVE_SETXATTR is true. </span>
<a name="l00189"></a>00189 <span class="comment">int getxattr(const char* path, const char* name, char* value, size_t size)</span>
<a name="l00190"></a>00190 <span class="comment">    //Read an extended attribute. See getxattr(2). This should be implemented only if HAVE_SETXATTR is true. </span>
<a name="l00191"></a>00191 <span class="comment">int listxattr(const char* path, const char* list, size_t size)</span>
<a name="l00192"></a>00192 <span class="comment">    //List the names of all extended attributes. See listxattr(2). This should be implemented only if HAVE_SETXATTR is true. </span>
<a name="l00193"></a>00193 <span class="comment">*/</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="preprocessor">#endif</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 6 Feb 2016 for odfs by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
